{$I WaspLib/osrs.simba}

//TODO
//Antiban
//Form
//improve Looting, try using TRSENTITY for loot piles?
//use jsons?
//lumbridge fight club, cool name


type EMonster = enum(COW);

type
  ECombatState = enum (

    ATTACK, SEEK, LOOT, BURY_BONES,

    WALK_BANK, WALK_FIELD,

    OPEN_BANK, DEPOSIT_BANK, CLOSE_BANK
    );

type EBankLocation = enum (
        LUMBRIDGE
        );

 TCombat = record

    Monster: EMonster;
    BankLocation: EBankLocation;
    MonsterEntity: TRSEntity;
    BankObject, StaircaseObject: TRSObject;
    LootSplat: TRSHitSplat;
    Seeking: Boolean;

    Timer: TCountdown;
    RunLength: UInt64;

end;

 procedure TCombat.init(MaxTime: UInt64);
 begin
  case self.Monster of
    EMonster.COW:
    begin
      Map.Setup([Chunk(Box(49,52,50,50), [0])]);

      //self.MonsterEntity := TRSEntity.create(NPCsJSON.GetByName('Cow', 1).Item[0]);
      //writeln self.MonsterEntity;

      self.MonsterEntity := TRSEntity.Create(@Map.Walker, [1.6,1.6,3.75], 50 ,[[8553, 37104],[8619, 37110],[8674, 37140]], ['Cow'], [ERSMinimapDot.NPC]);
      self.MonsterEntity.Finder.Colors += [$454C5A, 0.828, EColorSpace.HSV, [2.354, 0.444, 0.204]];
      self.MonsterEntity.Finder.Colors += [$6A7C92, 0.663, EColorSpace.HSV, [2.449, 0.247, 0.305]];
      self.MonsterEntity.Finder.Colors += [$314750, 2.155, EColorSpace.HSV, [2.018, 0.450, 0.534]];
      self.MonsterEntity.Finder.Transformer.Grow := 3;
      self.MonsterEntity.Finder.Transformer.Erode := 2;

    end;
  end;

  case self.BankLocation of
    EBankLocation.LUMBRIDGE:
    begin
      Map.Add([Chunk(Box(49,51,50,50), [1,2])]);

      self.StaircaseObject := TRSObject.Create(@Map.Walker,[2,2,6],[[8724, 37599],[34836, 37598]], ['Staircase']);
      self.StaircaseObject.Finder.Colors += [$073C52, 1.928, EColorSpace.HSV, [2.078, 0.533, 0.390]];
      self.BankObject := TRSObject.Create(@Map.Walker,[1,1,1],[[34848, 37546]], ['Bank']);
      self.BankObject.Finder.Colors += [$125D78, 0.973, EColorSpace.HSV, [1.356, 1.356, 0.289]];
    end;
  end;

    //Map.Loader.Graph.BlockArea([8804, 37454, 8844, 37490], True);  //lumbridge pub
    Antiban.Zoom.Max := 50;
    options.SetZoomLevel(50);
    MainScreen.SetHighestPitch();

    self.Timer.start(MaxTime*ONE_MINUTE);

 end;

 function TCombat.SplatTimer(SearchTime:Uint64=4200): Boolean;
  var
   HitTimer: TCountDown;
   splats: TRSHitSplatArray;

  begin
    HitTimer.Start(SearchTime);

    repeat
      Splats := [];
      TRSHitSplat.Find(Splats);
      if Length(Splats) > 0 then
        HitTimer.Restart();
    until Result := HitTimer.IsFinished;

  end;

 function TCombat.Attack(): Boolean;
 var
 splats: TRSHitSplatArray;

 begin

  if options.ZoomLevel <> 50 then
    Options.SetZoomLevel(50);

  if self.MonsterEntity.Click() then
    SleepUntil(TRSHitsplat.Find(Splats),100,10000);

  if Length(Splats) > 0 then
    Self.LootSplat := Splats[0];

  Result := self.SplatTimer();

 end;




 //

function TCombat.AvailableCubiods(out Coordinates: TPointArray): TCuboidArray;
//finds and filters entitys visible on main screen, Returns an array of entities with no HPbars and that are visible on the mainscreen
//need to also filter array of coordinants that match returned entities
var
i: UInt16;


Entities: TCuboidArray;
Ebox: TBox;

HPBar: TRSHPBar;
HPBarA: TRSHPBarArray;

Y1Mod : Int32 := Mainscreen.NormalizeDistance(10);
Y2Mod : Int32 := Mainscreen.NormalizeDistance(15);

begin
  Entities := self.MonsterEntity.GetCuboidArray(map.Position(), Coordinates);
  if length(Entities) < 1 then exit; // if no entities found exit

  TRSHPBar.Find(HPBarA);

  if Length(HPBarA) < 1 then
    Result := Entities // if no hp bars found, return unmodified Etitiy array
  else
    begin
      for i := 0 to high(Entities) do
        begin
          Ebox := Entities[i].bounds; // convert cuboid to Tbox

          if not Mainscreen.bounds.overlap(Ebox) then continue(1); // if Entity Tbox not visible on main screen skip to next Entity

          EBox := [EBox.X1,EBox.Y1-Y1Mod,EBox.X2,EBox.Y2+Y2Mod]; // reduce size of Tbox
          Ebox := Ebox.Expand(0, MainScreen.Bounds); // keeps all Tbox parts inside visible mainscreen

          for HpBar in HpBarA do
            if HpBar.bounds.Overlap(Ebox) then continue(2); // if any HPbars overlap an Entity's Tbox skip to next Entity

          Result += Entities[i]; // if no HPBars overlap and cubiod is showing on the main screen, add that entity to the list of results
        end;
    end;
end;


Function TCombat.FindEntityTPA(CuboidArray: TCuboidArray; coordinates: TPointArray): T2DPointArray;
var
  i: Integer;
  found: TBooleanArray;

begin
  if self.MonsterEntity.Finder <> Default(TColorFinder) then
    begin
      self.MonsterEntity.Finder.FindEx(Result, found, cuboidArray);

      for i := High(found) downto 0 do
        if not found[i] then
          Delete(coordinates, i, 1);

      Exit;
    end;

    for i := 0 to High(cuboidArray) do
      Result += cuboidArray[i].ShapeFill();
end;

function TCombat.FilterToMS(t2pa: T2DPointArray): T2DPointArray;
//Takes input Array of TPA and removes any Tpoints outside of visible mainscreen
var
  tpa: TPointArray;

begin
  for tpa in t2pa do
    begin
       Result += tpa.ExtractBox(Mainscreen.bounds); //returns any points inside the mainscreen
    end;

end;

Function TCombat.HoverClick(T2pa: T2DPointArray; attempts: UInt16 = 2): Boolean;
//attempts to click a found TPA, checking against selected entities uptext and clicking if they match

//protect against not finding enough TPA's
var
  i: UInt16;
begin
  if High(T2pa) < attempts then
    Attempts := High(T2pa);

  for i := 0 to attempts do
    begin
      Mouse.Move(T2pa[i].RandomMean());
      if MainScreen.IsUpText(self.MonsterEntity.UpText) and Biometrics.RedClick(EMouseButton.LEFT, 2) then
        Exit(True);
    end;
end;

function TCombat.Attack2(FilterMS: Boolean = False): Boolean;
var
  Cuboids: TCuboidArray;
  T2pa: T2DPointArray;
  coordinates: TPointArray;
  splats: TRSHitSplatArray;

begin

  Cuboids := self.AvailableCubiods(coordinates);

  T2pa := self.FindEntityTPA(Cuboids, coordinates);

  if high(T2pa) < 1 then
    begin
      self.seeking := True;
      exit(True);
    end;

  if FilterMS then
    T2pa := self.FilterToMS(T2pa);

  if self.HoverClick(T2pa, 2) then
    SleepUntil(TRSHitsplat.Find(Splats),100,10000);

  if Length(Splats) > 0 then
    Self.LootSplat := Splats[0];

  Result := self.SplatTimer();

end;


function TCombat.Looter(): Boolean;
  var
  i: Integer;
  pts: TPointArray;
  quad: TQuad;

begin
  pts := Minimap.GetDots(ERSMinimapDot.ITEM);

  //writeln length(pts);

  if length(pts) < 1 then
    begin
      writeln('loot dots found = ', pts);
      self.LootSplat := [];
      exit(True);
    end;

  pts := pts.sortfrom(Mainscreen.Point2MM(self.LootSplat.Position,Map.Height()));


  for i := 0 to 1 do
    begin
      quad := minimap.point2msquad(pts[i],[0.5,0.5],Minimap.CompassRadians);
      //ShowOnTarget(quad);
      if i < 1 then
        mouse.move(quad);

      sleep(250,1000);

      if MainScreen.IsUpText(['Take Cowhide','Take Bones']) then // change to array of whitelisted items
        begin
        Mouse.Click(EMouseButton.LEFT);
        MainScreen.WaitRedClick();
        sleep(750,2000);
        end
      else
        Continue;

      if i < 1 then
        Mouse.Move([260,178]);
      sleep(500,1500);

//
//      if MainScreen.IsUpText(['Take Cowhide','Take Bones']) then // change to array of whitelisted items
//        begin
//        Mouse.Click(EMouseButton.LEFT);
//        MainScreen.WaitRedClick();
//        sleep(750,1000);
//        break;
//        end
//      else
//        Continue;

      if length(pts) < 2 then
        break;

    end;

    self.LootSplat := [];
end;

function TCombat.SeekTargets(): Boolean;
// move to a random point around the closest monster location
var
  RandT, closest: Tpoint;

begin
  self.Seeking := False;

  closest := self.MonsterEntity.Coordinates.SortFrom(Map.Position())[0]; //define nearest monster location
  RandT := TCircle.Create(closest.x, closest.y, 10).RandomPoint; //build a TPA circle and select a random point inside that circle

  Result := Map.Walker.WebWalk(self.MonsterEntity.Coordinates, 20, 1); // walk to the generated point

end;

function TCombat.BuryBones(): Boolean;
//buries all bones in inventory
begin

if Inventory.Items.Contains('Bones') then // check if any items in inventory are bones
  begin
    repeat
      begin
      Inventory.Items.Click('Bones'); // click first item found in inventory
      sleep(1300,3000); // wait for bone to be buried
      end;
    until not Inventory.Items.Contains('Bones'); // exits loop when no more bones found
  end;

end;

procedure TCombat.WalkBank();
begin

  if not Map.Position.InRange([8608, 37178],4) then
    begin
      repeat
        //writeln 'moving through gate';
        Map.Walker.WebWalk([8608, 37178],1,0); // just south of cow field gate
      until Map.Position.InRange([8608, 37178],4);
    end;


  //if not Map.Position.AnyInRange(Self.StaircaseObject.Coordinates,100) then
  //  begin
  //    repeat
  //      writeln 'moving close to stairs';
  //      Map.Walker.WebWalk([8802, 37560],10,0); // front of lumbridge castle
  //      //SleepUntil(Map.Position.AnyInRange(self.StaircaseObject.Coordinates,100),300,20000);
  //    until Map.Position.AnyInRange(Self.StaircaseObject.Coordinates,100);
  //  end;

  if not Map.Position.AnyInRange(Self.BankObject.Coordinates,100) then
    Begin
      repeat
        //writeln 'going upstairs';
        //Map.Walker.WebWalk([8730, 37592],10,0);
        //sleep(1000,2000);
        self.StaircaseObject.WalkInteract(['Top']);
        SleepUntil(Map.Position.AnyInRange(self.BankObject.Coordinates,100),300,20000);
      until Map.Position.AnyInRange(Self.BankObject.Coordinates,100);
    end;

  //if not Map.Position.AnyInRange(Self.BankObject.Coordinates,10) then
  //  Begin
  //    repeat
  //      writeln 'moving to bank';
  //      Map.Walker.WebWalk([34851, 37552],10,0);
  //      SleepUntil(Map.Position.AnyInRange(self.BankObject.Coordinates,10),300,20000);
  //    until Map.Position.AnyInRange(Self.BankObject.Coordinates,10);
  //  end;

end;

procedure Tcombat.WalkField();
begin

  //if not Map.Position.InRange([8774, 37555],50) and not Map.Position.AnyInRange(self.MonsterEntity.Coordinates,200) then
  if Map.Position.InRange([34850, 37548],100) then
    begin
      repeat
        //writeln 'going downstairs';
        Map.Walker.WebWalk([34839, 37589],10,0);
        sleep(1000,2000);
        self.StaircaseObject.Interact(['Bottom']);
        SleepUntil(Map.Position.InRange([8774, 37555],100),300,20000);
      until Map.Position.InRange([8774, 37555],100);
    end;

  if not Map.Position.AnyInRange(self.MonsterEntity.Coordinates,50) then
    begin
      repeat
        //writeln 'going to field';
        Map.Walker.WebWalk(self.MonsterEntity.Coordinates,20,0);
        SleepUntil(Map.Position.AnyInRange(self.MonsterEntity.Coordinates,20),300,20000);
      until Map.Position.AnyInRange(self.MonsterEntity.Coordinates,20);
    end;

end;

procedure TCombat.OpenBank();
begin
  Bank.Open(self.bankObject);
  //self.BankObject.Click();
  sleepuntil(Bank.IsOpen(),500,20000);

  Biometrics.sleep(1000,5000);
end;

procedure TCombat.CloseBank();
begin
  Bank.Close(50);
  Biometrics.sleep(500,3000);

end;

procedure TCombat.DepositAll();
begin
  Bank.DynamicButtons[ERSBankDynamicButtons.DEPOSIT_INVENTORY].Click();
  SleepUntil(Inventory.Slots.Count() = 0,100,10000);
  Biometrics.sleep(1000,5000);
end;

function TCombat.GetState(): ECombatState;

var
selected: Int64;
selBox: Tbox;

begin

  selected := Inventory.GetSelected();
  if selected > -1 then
  begin
    writeln('it happened again boss, slot= ', selected);
    Inventory.Select(selected);
    selBox := Inventory.slots.box(selected);
    mouse.click(selbox, EMouseButton.LEFT);
    sleepuntil(not Inventory.IsSelected(selected), 100, 10000);
    sleep(500,1500);
  end;

  if self.Seeking then
    Exit(ECombatState.SEEK);

  Inventory.Open();

  If Inventory.IsFull() and Inventory.Items.ContainsAny(['Bones']) then
    Exit(EcombatState.BURY_BONES);

  If not Bank.IsOpen and Inventory.IsFull() and Map.Position.AnyInRange(self.BankObject.Coordinates,50) then
  Exit(EcombatState.OPEN_BANK);

  If Bank.IsOpen then
    If Inventory.IsFull() then
      Exit(EcombatState.DEPOSIT_BANK)
    else
      Exit(EcombatState.CLOSE_BANK);

  if Inventory.IsFull() and not Map.Position.AnyInRange(self.BankObject.Coordinates,50) then
    Exit(EcombatState.WALK_BANK);

  if not Inventory.IsFull() and not Map.Position.AnyInRange(self.MonsterEntity.Coordinates,100) then
    Exit(EcombatState.WALK_FIELD);

  if self.LootSplat.Position.X > 0 then
    Exit(EcombatState.LOOT);

  if not Inventory.IsFull() and Map.Position.AnyInRange(self.MonsterEntity.Coordinates,50) then
    Exit(ECombatState.ATTACK);



end;


procedure TCombat.Run();
 var
  state: ECombatState;
  begin

    self.init(360);// time in minutes

    //showontarget(self.StaircaseObject);
    //map.Debug();

    while self.Timer.remaining > 0 do
      begin
        state := self.GetState();
        writeln GetDebugLn(ToString(state));

        case state of

          ECombatState.ATTACK: self.Attack2();
          ECombatState.SEEK: self.SeekTargets();
          ECombatState.LOOT: self.Looter();
          ECombatState.BURY_BONES: self.BuryBones();

          //ECombatState.OPEN_BANK: self.OpenBank();
          ECombatState.OPEN_BANK: Bank.Open(self.bankObject);
          ECombatState.CLOSE_BANK: self.CloseBank;
          ECombatState.DEPOSIT_BANK: self.DepositAll;

          ECombatState.WALK_BANK: self.WalkBank();
          ECombatState.WALK_FIELD: self.WalkField();
        end;

      end;

end;


 var
  MyCombat: Tcombat;

 begin

 MyCombat.run();

 //MyCombat.init(50);
 //while true do
 // showontarget(MyCombat.MonsterEntity);
// map.debug();
 //MyCombat.WalkField();
 //MyCombat.WalkBank();

 end.
